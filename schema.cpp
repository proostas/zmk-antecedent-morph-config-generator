#include "schema.hpp"
#include <QDebug>
#include <QFile>
#include <QRegularExpression>

Schema::Schema(QObject *parent)
    : QObject{parent}
{
    m_kindMap = {
        {"English", English},
        {"Cpp", Cpp},
        {"CMake", CMake}
    };

    m_orderedSymbols = {"Q", "W", "F", "P", "B", "J", "L", "U", "Y", "‘",
                        "A", "R", "S", "T", "G", "M", "N", "E", "I", "O",
                        "Z", "X", "C", "D", "V", "K", "H", ",", ".", "/",
                        "{", "(", "*", ")", "}",
                        ":", "$", "%", "^", "+",
                        "~", "!", "@", "#", "|",
                        "&", "_",
                        "[", "7", "8", "9", "]",
                        ";", "4", "5", "6", "=",
                        "`", "1", "2", "3", "\\",
                        "0", "-", " "
    };
}

bool Schema::isValid() const
{
    if (m_type == UnknownType)
        return false;

    if (m_kind == UnknownKind)
        return false;

    for (auto i = m_antecedents.cbegin(); i != m_antecedents.cend(); i++) {
        if (!i.value()->isValid(m_type))
            return false;
    }

    return true;
}

void Schema::generateConfig(QTextStream& out) const
{
    emit logEvent("Begining config generation");
    out << QString("// %1 schema version %2\n").arg(m_name, m_version);
    out << "// Automatically generated by ZMK Antecedent Morph Config Generator\n\n/ {\n";
    out << QString{}.fill(' ', 4) << "behaviors {\n";
    generateBaseLayerBehaviors(out);
    if (m_type == Deep) {
        generateMouseLayerBehaviors(out);
        generateNavigationLayerBehaviors(out);
        generateMediaLayerBehaviors(out);
        generateFunctionLayerBehaviors(out);
        generateNumberLayerBehaviors(out);
        generateSymbolLayerBehaviors(out);
    }
    out << QString{}.fill(' ', 4) << "};\n";
    generateMacros(out);
    out << "};\n";
    emit logEvent("Finished config generation");
}

bool Schema::load(const QString &filePath)
{
    emit logEvent("Loading data");
    clear();
    emit logEvent("Cleared the previous schema data");

    QFile file{filePath};
    if (!file.open(QFile::ReadOnly|QFile::Text)) {
        emit logEvent(QString("Failed to open file: %1").arg(file.errorString()));
        return false;
    }

    QTextStream in{&file};
    QStringList row;

    QHash<QString,bool> morphLabels;

    int rNumber{0};
    while (readCSVRow(in, &row)) {
        if (!rNumber) {
            if (auto level0 = row.value(0, ""); level0 != "level0") {
                emit logEvent(QString("Incorrect CVS format: %1").arg(level0));
                return false;
            }

            if (row.count() == 2) {
                emit logEvent("Detected Flat schema format");
                m_type = Flat;
            } else if (row.count() == 3) {
                emit logEvent("Detected Deep schema format");
                m_type = Deep;
            } else {
                emit logEvent(QString("Incorrect CVS format: %1").arg(row.count()));
                return false;
            }
        } else {
            if (auto symbol = row.value(0,""); !symbol.isEmpty()) {
                if (symbol.length() == 1) {
                    if (m_antecedents.contains(symbol)) {
                        emit logEvent(QString("Detected duplicated antecedent: %1").arg(symbol));
                        return false;
                    }
                    if (m_curAntecedent) {
                        emit logEvent(QString("%1 is %2").arg(m_curAntecedent->symbol(), (m_curAntecedent->isValid(m_type) ? "valid" : "invalid")));
                    }
                    m_curAntecedent = std::make_shared<Antecedent>(symbol);
                    m_antecedents[symbol] = m_curAntecedent;
                } else {
                    static QRegularExpression re{"(\\w+) v(\\d+.\\d+)"};
                    if (auto match = re.match(symbol); match.hasMatch()) {
                        m_name = match.captured(1);
                        m_kind = m_kindMap.value(m_name, UnknownKind);
                        m_version = match.captured(2);
                    } else {
                        emit logEvent(QString("Skipping \"%1\"").arg(symbol));
                    }
                }
            } else if (auto level1 = row.value(1,""); !level1.isEmpty()) {
                if (Layer::isLayer(level1)) {
                    m_curLayer = m_curAntecedent->addLayer(level1);
                } else {
                    m_curAntecedent->addMorph(level1, morphLabels);
                }
            } else {
                m_curLayer->addMorph(row.value(2,""), morphLabels);
            }
        }

        rNumber++;
    }

    if (m_curAntecedent) {
        emit logEvent(QString("%1 is %2").arg(m_curAntecedent->symbol(), (m_curAntecedent->isValid(m_type) ? "valid" : "invalid")));
    }

    m_curAntecedent = nullptr;
    m_curLayer = nullptr;

    emit logEvent("Data has been loaded");

    return true;
}

bool Schema::save(const QString &filePath)
{
    QFile file{filePath};
    if (!file.open(QFile::WriteOnly|QFile::Truncate)) {
        emit logEvent(QString("Failed to open file: %1").arg(file.errorString()));
        return false;
    }

    QTextStream out{&file};
    generateConfig(out);

    return true;
}

void Schema::clear()
{
    m_type = UnknownType;
    m_kind = UnknownKind;
    m_name.clear();
    m_version.clear();
    m_antecedents.clear();
}

QString Schema::behaviorNodeLabel(Kind kind)
{
    QString out{"am"};
    switch (kind) {
    case UnknownKind:
        break;
    case English:
        out += "en";
        break;
    case Cpp:
        out += "cpp";
        break;
    case CMake:
        out += "cmk";
        break;
    }
    return out;
}

QString Schema::behaviorNodeName(Kind kind)
{
    QString out{"am_"};
    switch (kind) {
    case UnknownKind:
        break;
    case English:
        out += "eng";
        break;
    case Cpp:
        out += "cpp";
        break;
    case CMake:
        out += "cmake";
        break;
    }
    return out;
}

QString Schema::behaviorLabel(Kind kind)
{
    return behaviorNodeName(kind).toUpper();
}

QString Schema::behavior(const QString &nodeLabel, const QString &nodeName, const QString &label, const QString &bindings, const QString &antecedents)
{
    static QString tmpl = R"TMPL(
        %1: %2 {
            compatible = "zmk,behavior-antecedent-morph";
            label = "%3";
            #binding-cells = <0>;
            defaults = <&none>;
            bindings = %4;
            antecedents = <%5>;
            max-delay-ms = <U_ANTMORPH_DELAY>;
        };)TMPL";

    auto out = tmpl;
    out = out.sliced(1);
    return out.arg(nodeLabel, nodeName, label, bindings, antecedents);
}

bool Schema::readCSVRow (QTextStream &in, QStringList *row)
{
    // the content of this func is borrowed from here:
    // https://gist.github.com/JC3/4ec7f6f2883aec7087bff342494bd791
    // but modified a bit for ; as separators and to recognize Unicode chars

    static const int delta[][5] = {
        //  ;    "   \n    ?  eof
        {   1,   2,  -1,   0,  -1  }, // 0: parsing (store char)
        {   1,   2,  -1,   0,  -1  }, // 1: parsing (store column)
        {   3,   4,   3,   3,  -2  }, // 2: quote entered (no-op)
        {   3,   4,   3,   3,  -2  }, // 3: parsing inside quotes (store char)
        {   1,   3,  -1,   0,  -1  }, // 4: quote exited (no-op)
        // -1: end of row, store column, success
        // -2: eof inside quotes
    };

    row->clear();

    if (in.atEnd())
        return false;

    int state = 0, t;
    QChar ch;
    QString cell;

    while (state >= 0) {

        if (in.atEnd())
            t = 4;
        else {
            in >> ch;
            if (ch == ';') t = 0;
            else if (ch == '\"') t = 1;
            else if (ch == '\n') t = 2;
            else t = 3;
        }

        state = delta[state][t];

        if (state == 0 || state == 3) {
            cell += ch;
        } else if (state == -1 || state == 1) {
            row->append(cell);
            cell = "";
        }

    }

    if (state == -2) {
        throw std::runtime_error("End-of-file found while inside quotes.");
    }

    return true;
}

void Schema::generateBaseLayerBehaviors(QTextStream& out) const
{
    out << QString{}.fill(' ', 8) <<  "// Base layer\n";
    // Generate NE behavior
    auto nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(NorthEast);
    auto nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(NorthEast);
    auto label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(NorthEast);
    QStringList bindings{};
    QStringList antecedents;
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(NorthEast)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), NorthEast);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate E behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(East);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(East);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(East);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(East)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), East);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate SE behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(SouthEast);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(SouthEast);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(SouthEast);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(SouthEast)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), SouthEast);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate SW behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(SouthWest);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(SouthWest);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(SouthWest);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(SouthWest)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), SouthWest);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate NW behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(NorthWest);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(NorthWest);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(NorthWest);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(NorthWest)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), NorthWest);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    emit logEvent("Generated Base layer behaviors");
}

void Schema::generateMouseLayerBehaviors(QTextStream& out) const
{
    out << QString{}.fill(' ', 8) <<  "// Mouse layer\n";
    // Generate NE behavior
    auto nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(NorthEast, Layer::Mouse);
    auto nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(NorthEast, Layer::Mouse);
    auto label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(NorthEast, Layer::Mouse);
    QStringList bindings{};
    QStringList antecedents{};
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(NorthEast, Layer::Mouse)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), NorthEast, Layer::Mouse);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate E behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(East, Layer::Mouse);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(East, Layer::Mouse);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(East, Layer::Mouse);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(East, Layer::Mouse)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), East, Layer::Mouse);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate SE behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(SouthEast, Layer::Mouse);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(SouthEast, Layer::Mouse);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(SouthEast, Layer::Mouse);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(SouthEast, Layer::Mouse)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), SouthEast, Layer::Mouse);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    emit logEvent("Generated Mouse layer behaviors");
}

void Schema::generateNavigationLayerBehaviors(QTextStream& out) const
{
    out << QString{}.fill(' ', 8) <<  "// Navigation layer\n";
    // Generate NE behavior
    auto nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(NorthEast, Layer::Navigation);
    auto nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(NorthEast, Layer::Navigation);
    auto label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(NorthEast, Layer::Navigation);
    QStringList bindings{};
    QStringList antecedents{};
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(NorthEast, Layer::Navigation)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), NorthEast, Layer::Navigation);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate E behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(East, Layer::Navigation);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(East, Layer::Navigation);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(East, Layer::Navigation);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(East, Layer::Navigation)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), East, Layer::Navigation);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate SE behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(SouthEast, Layer::Navigation);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(SouthEast, Layer::Navigation);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(SouthEast, Layer::Navigation);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(SouthEast, Layer::Navigation)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), SouthEast, Layer::Navigation);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    emit logEvent("Generated Navigation layer behaviors");
}

void Schema::generateMediaLayerBehaviors(QTextStream& out) const
{
    out << QString{}.fill(' ', 8) <<  "// Media layer\n";
    // Generate NE behavior
    auto nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(NorthEast, Layer::Media);
    auto nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(NorthEast, Layer::Media);
    auto label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(NorthEast, Layer::Media);
    QStringList bindings{};
    QStringList antecedents{};
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(NorthEast, Layer::Media)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), NorthEast, Layer::Media);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate E behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(East, Layer::Media);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(East, Layer::Media);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(East, Layer::Media);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(East, Layer::Media)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), East, Layer::Media);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate SE behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(SouthEast, Layer::Media);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(SouthEast, Layer::Media);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(SouthEast, Layer::Media);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(SouthEast, Layer::Media)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), SouthEast, Layer::Media);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    emit logEvent("Generated Media layer behaviors");
}

void Schema::generateFunctionLayerBehaviors(QTextStream& out) const
{
    out << QString{}.fill(' ', 8) <<  "// Function layer\n";
    // Generate SW behavior
    auto nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(SouthWest, Layer::Function);
    auto nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(SouthWest, Layer::Function);
    auto label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(SouthWest, Layer::Function);
    QStringList bindings{};
    QStringList antecedents{};
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(SouthWest, Layer::Function)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), SouthWest, Layer::Function);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate W behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(West, Layer::Function);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(West, Layer::Function);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(West, Layer::Function);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(West, Layer::Function)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), West, Layer::Function);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate NW behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(NorthWest, Layer::Function);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(NorthWest, Layer::Function);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(NorthWest, Layer::Function);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(NorthWest, Layer::Function)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), NorthWest, Layer::Function);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    emit logEvent("Generated Function layer behaviors");
}

void Schema::generateNumberLayerBehaviors(QTextStream& out) const
{
    out << QString{}.fill(' ', 8) <<  "// Number layer\n";
    // Generate SW behavior
    auto nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(SouthWest, Layer::Number);
    auto nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(SouthWest, Layer::Number);
    auto label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(SouthWest, Layer::Number);
    QStringList bindings{};
    QStringList antecedents{};
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(SouthWest, Layer::Number)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), SouthWest, Layer::Number);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate W behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(West, Layer::Number);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(West, Layer::Number);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(West, Layer::Number);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(West, Layer::Number)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), West, Layer::Number);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate NW behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(NorthWest, Layer::Number);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(NorthWest, Layer::Number);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(NorthWest, Layer::Number);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(NorthWest, Layer::Number)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), NorthWest, Layer::Number);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    emit logEvent("Generated Number layer behaviors");
}

void Schema::generateSymbolLayerBehaviors(QTextStream& out) const
{
    out << QString{}.fill(' ', 8) <<  "// Symbol layer\n";
    // Generate SW behavior
    auto nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(SouthWest, Layer::Symbol);
    auto nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(SouthWest, Layer::Symbol);
    auto label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(SouthWest, Layer::Symbol);
    QStringList bindings{};
    QStringList antecedents{};
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(SouthWest, Layer::Symbol)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), SouthWest, Layer::Symbol);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate W behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(West, Layer::Symbol);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(West, Layer::Symbol);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(West, Layer::Symbol);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(West, Layer::Symbol)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), West, Layer::Symbol);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    // Generate NW behavior
    nodeLabel = Schema::behaviorNodeLabel(m_kind) + Layer::behaviorNodeLabel(NorthWest, Layer::Symbol);
    nodeName = Schema::behaviorNodeName(m_kind) + "_" + Layer::behaviorNodeName(NorthWest, Layer::Symbol);
    label = Schema::behaviorLabel(m_kind) + "_" + Layer::behaviorLabel(NorthWest, Layer::Symbol);
    bindings.clear();
    antecedents.clear();
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;
        if (!m_antecedents[*i]->isEmpty(NorthWest, Layer::Symbol)) {
            bindings << m_antecedents[*i]->binding(Schema::behaviorNodeLabel(m_kind), NorthWest, Layer::Symbol);
            antecedents << m_antecedents[*i]->keycode();
        }
    }
    out << behavior(nodeLabel, nodeName, label, bindings.join(", "), antecedents.join(" ")) << "\n";

    emit logEvent("Generated Symbol layer behaviors");
}

void Schema::generateMacros(QTextStream& out) const
{
    out << QString{}.fill(' ', 4) << "macros {\n";
    for (auto i = m_orderedSymbols.cbegin(); i != m_orderedSymbols.cend(); ++i) {
        if (!m_antecedents.contains(*i))
            continue;

        if (m_antecedents[*i]->isEmpty())
            continue;

        out << m_antecedents[*i]->macros(Schema::behaviorNodeLabel(m_kind)).join("\n") << "\n";
    }
    out << QString{}.fill(' ', 4) << "};\n";

    emit logEvent("Generated macros");
}

std::vector<Layer::Type> Antecedent::s_orderedLayers = {Layer::Mouse, Layer::Navigation, Layer::Media, Layer::Function, Layer::Number, Layer::Symbol};

Antecedent::Antecedent(QString symbol)
    : m_symbol{symbol}
{

}

LayerPtr Antecedent::addLayer(const QString &label)
{
    auto layer = std::make_shared<Layer>(label);
    m_layers[layer->type()] = layer;
    return layer;
}

void Antecedent::addMorph(const QString &phrase, QHash<QString,bool>& labels)
{
    auto m = std::make_shared<Morph>(phrase);
    while (labels.contains(m->nodeLabel())) {
        m->incrementPostfix();
    }
    labels[m->nodeLabel()] = true;
    m_morphs.push_back(m);
}

bool Antecedent::isValid(const Schema::Type schemaType) const
{
    if (schemaType == Schema::Flat) {
        return m_morphs.size() == 6 || m_morphs.size() == 5;
    }

    return m_morphs.size() == 6 && m_layers.size() == 6;
}

bool Antecedent::isEmpty(Schema::Direction dir, Layer::Type layerType) const
{
    if (layerType == Layer::Unknown) {
        return m_morphs[Layer::mapDirectionToIndex(dir, layerType)]->isEmpty();
    }

    return m_layers[layerType]->isEmpty(dir);
}

bool Antecedent::isEmpty() const
{
    for (auto i = m_morphs.cbegin(); i != m_morphs.cend(); ++i) {
        if (!(*i)->isEmpty())
            return false;
    }

    for (auto i = m_layers.cbegin(); i != m_layers.cend(); ++i) {
        if (!i.value()->isEmpty())
            return false;
    }

    return true;
}

QString Antecedent::keycode() const
{
    return Morph::zmkKeycode(m_symbol.toLower());
}

QStringList Antecedent::morphNodeLabels() const
{
    QStringList list{};
    for (auto i = m_morphs.cbegin(); i != m_morphs.cend(); i++) {
        if (!(*i)->isEmpty())
            list << (*i)->nodeLabel();
    }
    for (auto i = s_orderedLayers.cbegin(); i != s_orderedLayers.cend(); i++) {
        if (!m_layers.contains(*i))
            continue;

        list << m_layers[*i]->morphNodeLabels();
    }
    return list;
}

QString Antecedent::binding(const QString &prefix, Schema::Direction dir, Layer::Type layerType)
{
    if (layerType == Layer::Unknown) {
        return m_morphs[Layer::mapDirectionToIndex(dir, layerType)]->binding(m_symbol, prefix);
    }

    return m_layers[layerType]->binding(prefix, m_symbol, dir);
}

QStringList Antecedent::macros(const QString &prefix) const
{
    QStringList list{};
    for (auto i = m_morphs.cbegin(); i != m_morphs.cend(); i++) {
        if (!(*i)->isEmpty() && !(*i)->isSingleLettered(m_symbol))
            list << (*i)->macro(m_symbol, prefix);
    }
    for (auto i = s_orderedLayers.cbegin(); i != s_orderedLayers.cend(); i++) {
        if (!m_layers.contains(*i))
            continue;

        list << m_layers[*i]->macros(m_symbol, prefix);
    }
    return list;
}

QHash<QString,Layer::Type> Layer::s_typeMap = {
    {"MOS", Layer::Mouse},
    {"NAV", Layer::Navigation},
    {"MED", Layer::Media},
    {"FUN", Layer::Function},
    {"NUM", Layer::Number},
    {"SYM", Layer::Symbol}
};

Layer::Layer(QString label)
    : m_label{label},
      m_type{s_typeMap.value(label, Unknown)}
{

}

int Layer::mapDirectionToIndex(Schema::Direction dir, Type layerType)
{
    switch (layerType) {
    case Unknown:
        switch (dir) {
        case Schema::NorthEast:
            return 0;
        case Schema::East:
            return 1;
        case Schema::SouthEast:
            return 2;
        case Schema::SouthWest:
            return 3;
        case Schema::NorthWest:
            return 5;
        }
    case Mouse:
    case Navigation:
    case Media:
        switch (dir) {
        case Schema::NorthEast:
            return 0;
        case Schema::East:
            return 1;
        case Schema::SouthEast:
            return 2;
        }
    case Function:
    case Number:
    case Symbol:
        switch (dir) {
        case Schema::NorthWest:
            return 2;
        case Schema::West:
            return 1;
        case Schema::SouthWest:
            return 0;
        }
    }

    return -1;
}

inline bool Layer::isLayer(const QString &v)
{
    return s_typeMap.contains(v);
}

QString Layer::behaviorNodeLabel(Schema::Direction dir, Type layerType)
{
    QString out{};
    switch (layerType) {
    case Unknown:
        break;
    case Mouse:
        out += "mos";
        break;
    case Navigation:
        out += "nav";
        break;
    case Media:
        out += "med";
        break;
    case Function:
        out += "fun";
        break;
    case Number:
        out += "num";
        break;
    case Symbol:
        out += "sym";
        break;
    }

    switch (dir) {
    case Schema::NorthEast:
        out += "ne";
        break;
    case Schema::East:
        out += "e";
        break;
    case Schema::SouthEast:
        out += "se";
        break;
    case Schema::SouthWest:
        out += "sw";
        break;
    case Schema::West:
        out += "w";
        break;
    case Schema::NorthWest:
        out += "nw";
        break;
    }

    return out;
}

QString Layer::behaviorNodeName(Schema::Direction dir, Type layerType)
{
    QString out{};
    switch (layerType) {
    case Unknown:
        break;
    case Mouse:
        out += "mouse_";
        break;
    case Navigation:
        out += "navigation_";
        break;
    case Media:
        out += "media_";
        break;
    case Function:
        out += "function_";
        break;
    case Number:
        out += "number_";
        break;
    case Symbol:
        out += "symbol_";
        break;
    }

    switch (dir) {
    case Schema::NorthEast:
        out += "north_east";
        break;
    case Schema::East:
        out += "east";
        break;
    case Schema::SouthEast:
        out += "south_east";
        break;
    case Schema::SouthWest:
        out += "south_west";
        break;
    case Schema::West:
        out += "west";
        break;
    case Schema::NorthWest:
        out += "north_west";
        break;
    }

    return out;
}

QString Layer::behaviorLabel(Schema::Direction dir, Type layerType)
{
    return behaviorNodeName(dir, layerType).toUpper();
}

void Layer::addMorph(const QString &phrase, QHash<QString, bool> &labels)
{
    auto m = std::make_shared<Morph>(phrase);
    while (labels.contains(m->nodeLabel())) {
        m->incrementPostfix();
    }
    labels[m->nodeLabel()] = true;
    m_morphs.push_back(m);
}

bool Layer::isEmpty(Schema::Direction dir) const
{
    return m_morphs[mapDirectionToIndex(dir, m_type)]->isEmpty();
}

bool Layer::isEmpty() const
{
    for (auto i = m_morphs.cbegin(); i != m_morphs.cend(); ++i) {
        if (!(*i)->isEmpty())
            return false;
    }

    return true;
}

QStringList Layer::morphNodeLabels() const
{
    QStringList list{};
    for (auto i = m_morphs.cbegin(); i != m_morphs.cend(); i++) {
        if (!(*i)->isEmpty())
            list << (*i)->nodeLabel();
    }
    return list;
}

QString Layer::binding(const QString &prefix, const QString &symbol, Schema::Direction dir) const
{
    return m_morphs[mapDirectionToIndex(dir, m_type)]->binding(symbol, prefix);
}

QStringList Layer::macros(const QString &symbol, const QString &prefix) const
{
    QStringList list{};
    for (auto i = m_morphs.cbegin(); i != m_morphs.cend(); i++) {
        if (!(*i)->isEmpty() && !(*i)->isSingleLettered(symbol))
            list << (*i)->macro(symbol, prefix);
    }
    return list;
}

Morph::Morph(const QString &phrase)
    : m_phrase{phrase},
      m_postfix{0}
{

}

void Morph::incrementPostfix()
{
    m_postfix++;
}

bool Morph::isEmpty() const
{
    return m_phrase.isEmpty() || m_phrase == "-" || m_phrase == "N/A" || m_phrase == " ";
}

bool Morph::isSingleLettered(const QString &symbol) const
{
    return m_phrase.length() == 2 && m_phrase.first(1).toLower() == symbol.toLower();
}

QString Morph::nodeLabel() const
{
    static QRegularExpression replaceRe{"[- ]"};
    static QRegularExpression squeezeRe{"(?<=([- ]))\\1"};
    static QRegularExpression clearRe{"[^a-z0-9 -]"};

    auto label = m_phrase.toLower().trimmed();
    label.replace(squeezeRe, "");
    label.replace(clearRe, "");
    label = label.trimmed();
    label.replace(replaceRe, "_");

    if (label.length() > 15)
        label = label.first(15);

    return label + (m_postfix ? QString::number(m_postfix) : QString{});
}

QString Morph::binding(const QString& symbol, const QString &prefix) const
{
    if (isSingleLettered(symbol)) {
        return QString{"<&kp %1>"}.arg(zmkKeycode(m_phrase.sliced(1,1)));
    }

    return QString{"<&%1_%2>"}.arg(prefix, nodeLabel());
}

QString Morph::macro(const QString &symbol, const QString &prefix) const
{
    QString tmpl{R"TMPL(%1_%2: %1_%2 {
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            wait-ms = <U_ANTMORPH_MACRO_WAIT>;
            tap-ms = <U_ANTMORPH_MACRO_TAP>;
            // %3%4
            bindings = <%5>;
        };)TMPL"};

    QString out = tmpl;
    QString pre, firstOp;
    QString phrase = m_phrase;
    if (symbol.toLower() == phrase.first(1).toLower()) {
        pre = QString("(") + phrase.first(1).toLower() + ")";
        firstOp = "";
        phrase = phrase.sliced(1);
    } else {
        pre = QString("[") + symbol.toLower() + "]";
        firstOp = "&kp BSPC ";
    }

    QString bindings;
    for (auto l: phrase.split(QString())) {
        if (l.isEmpty())
            continue;

        bindings += QString("&kp ") + zmkKeycode(l) + " ";
    }
    return out.arg(prefix, nodeLabel(), pre, phrase, firstOp + bindings.trimmed()).prepend(QString{}.fill(' ', 8));
}

QString Morph::zmkKeycode(const QString &c)
{
    static QHash<QString,QString> map{
        {"a",  "A"},
        {"b",  "B"},
        {"c",  "C"},
        {"d",  "D"},
        {"e",  "E"},
        {"f",  "F"},
        {"g",  "G"},
        {"h",  "H"},
        {"i",  "I"},
        {"j",  "J"},
        {"k",  "K"},
        {"l",  "L"},
        {"m",  "M"},
        {"n",  "N"},
        {"o",  "O"},
        {"p",  "P"},
        {"q",  "Q"},
        {"r",  "R"},
        {"s",  "S"},
        {"t",  "T"},
        {"u",  "U"},
        {"v",  "V"},
        {"w",  "W"},
        {"x",  "X"},
        {"y",  "Y"},
        {"z",  "Z"},

        {"A",  "LS(A)"},
        {"B",  "LS(B)"},
        {"C",  "LS(C)"},
        {"D",  "LS(D)"},
        {"E",  "LS(E)"},
        {"F",  "LS(F)"},
        {"G",  "LS(G)"},
        {"H",  "LS(H)"},
        {"I",  "LS(I)"},
        {"J",  "LS(J)"},
        {"K",  "LS(K)"},
        {"L",  "LS(L)"},
        {"M",  "LS(M)"},
        {"N",  "LS(N)"},
        {"O",  "LS(O)"},
        {"P",  "LS(P)"},
        {"Q",  "LS(Q)"},
        {"R",  "LS(R)"},
        {"S",  "LS(S)"},
        {"T",  "LS(T)"},
        {"U",  "LS(U)"},
        {"V",  "LS(V)"},
        {"W",  "LS(W)"},
        {"X",  "LS(X)"},
        {"Y",  "LS(Y)"},
        {"Z",  "LS(Z)"},

        {"0",  "N0"},
        {"1",  "N1"},
        {"2",  "N2"},
        {"3",  "N3"},
        {"4",  "N4"},
        {"5",  "N5"},
        {"6",  "N6"},
        {"7",  "N7"},
        {"8",  "N8"},
        {"9",  "N9"},

        {" ",  "SPACE"},
        {"!",  "EXCL"},
        {"@",  "AT"},
        {"#",  "HASH"},
        {"$",  "DLLR"},
        {"%",  "PRCNT"},
        {"^",  "CARET"},
        {"&",  "AMPS"},
        {"*",  "STAR"},
        {"(",  "LPAR"},
        {")",  "RPAR"},
        {"=",  "EQUAL"},
        {"+",  "PLUS"},
        {"-",  "MINUS"},
        {"_",  "UNDER"},
        {"/",  "FSLH"},
        {"?",  "QMARK"},
        {"\\", "BSLH"},
        {"|",  "PIPE"},
        {";", "SEMI"},
        {":",  "COLON"},
        {"'",  "APOS"},
        {"‘",  "APOS"},
        {"’",  "APOS"},
        {"\"", "DQT"},
        {"“",  "DQT"},
        {"”",  "DQT"},
        {",",  "COMMA"},
        {".",  "DOT"},
        {">",  "GT"},
        {"<",  "LT"},
        {"[",  "LBKT"},
        {"]",  "RBKT"},
        {"{",  "LBRC"},
        {"}",  "RBRC"},
        {"`",  "GRAVE"},
        {"~",  "TILDE"},

        {"←",  "LEFT"},
        {"⏎", "RET"},

        {"é",  "E"}
    };

    return map.value(c, QString{});
}
